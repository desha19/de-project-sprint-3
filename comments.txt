Приветствую, дорогой ревьюер!

Прошу при найденных ошибках поподробней описать проблему, так как для меня эта тема далась с трудом и в каких-то моментах я могу плавать, 
но я очень старался, даже пожертвовал первомайскими шашлыками :D

Спасибо за твою работу и фидбэк! :)

С наступившими майскими праздниками!!!

=========

Вторая итерация.

Добрый день, Карина!

Благадарю за оставленную подробную обратную связь! Всё максимально подробно и понятно.

Я учёл все замечания и внёс исправления:
- наполнение данными в таблице mart.f_customer_retention выполняется инкрементарно по временному периоду (строка: 22)
- так же добавил строчку "parameters={"date": {business_dt}})" в оператор "update_mart_f_customer_retention" sprint.py (строка: 201) 
  для того, что бы запрос смог выполниться инкрементарно по временному периоду.
- удаление выполняется инкременратно (mart.f_sales, строки: 2-6; mart.f_customer_retention, строки: 2-6)
- тблица mart.f_customer_retention наполняется данными из таблицы mart.f_sales вместо staging.user_order_log
- изменил порядок тасок (перед update_mart_f_customer_retention выполняется update_f_sales)

Трудности возникли с инкременратным удалением в таблице mart.f_customer_retention, долго разбирался за какое поле зацепиться, 
что бы вызвать проверку. В итоге написал подзапрпос, который проверяется есть ли такой period_name в нём. (Если я неправильно написал, 
пожалуйста подскажи по какому полю нужно выполнять проверку или в каком направлении двигаться.)

По поводу: "Подскажи, пожалуйста, что конкретно вызывало трудности?
Может я смогу найти доп материалы по этой теме или подсказать что-то."
У нас есть вот такой код:
business_dt = '{{ ds }}'

with DAG(
        'sales_mart',
        default_args=args,
        description='Provide default dag for sprint3',
        catchup=True,
        start_date=datetime.today() - timedelta(days=7),
        end_date=datetime.today() - timedelta(days=1),
) as dag:
Можно пожалуйста объяснить, как формируется временной период в этой части кода, как этот период попадает в '{{ ds }}'?
Вижу, что есть старт и конец в них формируется прошлая неделя, но не могу связать эти параметры с '{{ ds }}'.

Хочу поздравить тебя с наступившим праздником Пасхи!!! :)

=========

Третья итерация.

Карина, приветствую!

Исправил в запросе mart.f_customer_retention строчку с фильтром (строка: 22) на "where dc.date_actual >= date_trunc('week', '{{ds}}'::timestamp)"

Благодарю за пояснение '{{ ds }}', теперь мне стало ясно. :) 
А так же за ссылку, в этой статье довольно подробно раскрывается подкапотная работа DAG, как раз то что мне нужно.